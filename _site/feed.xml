<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>alphaGem&#39;s blog</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</description>
    <link>https://alphagem.github.io/</link>
    <atom:link href="https://alphagem.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 18 Apr 2018 21:42:55 +0800</pubDate>
    <lastBuildDate>Wed, 18 Apr 2018 21:42:55 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>输出语句调试科技系列</title>
        <description>&lt;p&gt;GDB都是邪教，printf系列调试大法好。（其实是我不会用GDB……）于是这里就是一些printf调试科技的总结。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;基础操作&lt;/h3&gt;

&lt;p&gt;如&lt;a href=&quot;/2018/03/11/Linux中Gedit的脚本设置&quot;&gt;Linux中Gedit的脚本设置&lt;/a&gt;一文所述，我们有如下的基础操作方法：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;cp&quot;&gt;#ifdef DEBUG
&lt;/span&gt;	&lt;span class=&quot;cp&quot;&gt;#define debug(a...) fprintf(stderr,a),fflush(stderr)
&lt;/span&gt;	&lt;span class=&quot;cp&quot;&gt;#else
&lt;/span&gt;	&lt;span class=&quot;cp&quot;&gt;#define debug(a...) 1
&lt;/span&gt;	&lt;span class=&quot;cp&quot;&gt;#endif&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;接着我们就只需要像调用printf函数一样地调用debug就可以实现当且仅当预定义了宏“DEBUG”才把错误信息输出到stderr。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;进阶操作&lt;/h3&gt;

&lt;p&gt;最近淆了个变长参数函数的用法，所以……&lt;/p&gt;

&lt;p&gt;首先引用头文件cstdarg，然后打出如下代码：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,...)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;cp&quot;&gt;#ifdef DEBUG
&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;va_list&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;va_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;va_arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;puts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fflush&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;va_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;接着就可以以如下方式进行调试：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;	&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;i,f[i]: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;变长参数这里以-1结尾，实际运用的时候可以以你需要的数字结尾，只要把db函数里面的循环终止条件改成等于你所设定的数字就好了。然后当且仅当预定义了宏DEBUG，程序会输出一行形如”i,f[i]: 2 10”这样的信息，就省去了每次调试打%d并且还要算好有几个%d之类的麻烦。比较适合那种要输出几百次调试的题目。&lt;/p&gt;
</description>
        <pubDate>Wed, 18 Apr 2018 00:00:00 +0800</pubDate>
        <link>https://alphagem.github.io/2018/04/18/%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5%E8%B0%83%E8%AF%95%E7%A7%91%E6%8A%80%E7%B3%BB%E5%88%97.html</link>
        <guid isPermaLink="true">https://alphagem.github.io/2018/04/18/%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5%E8%B0%83%E8%AF%95%E7%A7%91%E6%8A%80%E7%B3%BB%E5%88%97.html</guid>
        
        <category>信息竞赛</category>
        
        <category>调试</category>
        
        
        <category>信息竞赛</category>
        
      </item>
    
      <item>
        <title>現學現賣音韻學隨記一・從普通話福州話進行簡單中古漢語聲調推導</title>
        <description>&lt;p&gt;這裏主要介紹一些簡單的從普通話與福州話的發音推導出中古漢語聲調的方法。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;一些廢話&lt;/h3&gt;

&lt;p&gt;中古漢語的聲調分平上去入四聲，而根據聲母的清濁又分成陰陽，所以總共就是四聲八調。然而在語言的流變中有些聲調就被吃掉了。之前學習了一些從普通話上推中古漢語聲調的基本操作，然後突然意識到也可以用福州話上推，甚至兩者結合起來上推……&lt;/p&gt;

&lt;p&gt;這裏討論的都是比較一般的情況（因爲特殊字實在好多啊，有的還不好解釋）。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;從普通話上推&lt;/h3&gt;

&lt;p&gt;首先不考慮麻煩的要死的入聲字。&lt;/p&gt;

&lt;p&gt;普通話有陰平、陽平、上聲、去聲四個聲調，對應到中古漢語的平上去大概是這樣的&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;中古漢語&lt;/td&gt;
      &lt;td&gt;清平&lt;/td&gt;
      &lt;td&gt;濁平&lt;/td&gt;
      &lt;td&gt;清上&lt;/td&gt;
      &lt;td&gt;次濁上&lt;/td&gt;
      &lt;td&gt;全濁上&lt;/td&gt;
      &lt;td&gt;清去&lt;/td&gt;
      &lt;td&gt;濁去&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;普通話&lt;/td&gt;
      &lt;td&gt;陰平&lt;/td&gt;
      &lt;td&gt;陽平&lt;/td&gt;
      &lt;td&gt;上聲&lt;/td&gt;
      &lt;td&gt;上聲&lt;/td&gt;
      &lt;td&gt;去聲&lt;/td&gt;
      &lt;td&gt;去聲&lt;/td&gt;
      &lt;td&gt;去聲&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;平聲方面是比較清楚的，按清濁分陰陽。&lt;/p&gt;

&lt;p&gt;上聲中聲母是全清次清次濁的對應到普通話的上聲，聲母是全濁的對應到普通話的去聲。&lt;/p&gt;

&lt;p&gt;去聲字就對應到普通話的去聲。&lt;/p&gt;

&lt;p&gt;也就是說，對於一個陰平字，它上推到中古漢語會是清平字；&lt;/p&gt;

&lt;p&gt;對於一個陽平字，它上推到中古漢語會是濁平字；&lt;/p&gt;

&lt;p&gt;對於一個上聲字，它上推到中古漢語會是清上或者次濁上聲字，而清與次濁是很好分辨的，於是就可以判定一個上聲字聲母的清濁；&lt;/p&gt;

&lt;p&gt;對於一個去聲字，它可能是全濁來源或者去聲來源，但是注意到濁母清化“平送仄不送”的規則，如果普通話裏這個字的聲母是送氣的，那麼就說明這個字是清去（因爲全濁上聲字和濁去字不送氣），否則就是全濁上聲字或者濁去字。全濁上聲字和濁去字混得厲害，所以難以區分。&lt;/p&gt;

&lt;p&gt;接下來我們開始考慮入聲字。&lt;/p&gt;

&lt;p&gt;普通話裏，入聲字混到了平上去三聲裏面，而對應關係大概是這樣的&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;中古漢語&lt;/td&gt;
      &lt;td&gt;全清入聲字&lt;/td&gt;
      &lt;td&gt;次清入聲字&lt;/td&gt;
      &lt;td&gt;全濁入聲字&lt;/td&gt;
      &lt;td&gt;次濁入聲字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;普通話&lt;/td&gt;
      &lt;td&gt;四聲&lt;/td&gt;
      &lt;td&gt;四聲&lt;/td&gt;
      &lt;td&gt;陽平&lt;/td&gt;
      &lt;td&gt;去聲&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;但這種混亂中還是有一些規律的：對於一個陽平字，如果它是次清的，那麼它只能是平聲字，對於一個去聲字，如果它不是次濁的，那麼就不會是入聲字。&lt;/p&gt;

&lt;p&gt;所以入聲好混亂啊……怎麼辦呢？&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;從福州話上推&lt;/h3&gt;

&lt;p&gt;喜聞樂見的事情發生了。保留入聲字的福州話就不存在入派三聲的混亂狀況。&lt;/p&gt;

&lt;p&gt;所以我們就可以先列個表：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;中古漢語&lt;/td&gt;
      &lt;td&gt;清平&lt;/td&gt;
      &lt;td&gt;濁平&lt;/td&gt;
      &lt;td&gt;清上與次濁上&lt;/td&gt;
      &lt;td&gt;清去&lt;/td&gt;
      &lt;td&gt;全濁上與濁去&lt;/td&gt;
      &lt;td&gt;清入&lt;/td&gt;
      &lt;td&gt;濁入&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;福州話&lt;/td&gt;
      &lt;td&gt;陰平&lt;/td&gt;
      &lt;td&gt;陽平&lt;/td&gt;
      &lt;td&gt;上聲&lt;/td&gt;
      &lt;td&gt;陰去&lt;/td&gt;
      &lt;td&gt;陽去&lt;/td&gt;
      &lt;td&gt;陰入&lt;/td&gt;
      &lt;td&gt;陽入&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;看起來就比較規整了。全濁上這個……這就實在是沒救了啦……&lt;/p&gt;

&lt;p&gt;於是如果會講福州話的話就可以比較方便地判定聲調了。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;什麼……你福州話和我一樣講得很差，然後很多單字不會念只有組詞了纔會？&lt;/h3&gt;

&lt;p&gt;那就組詞啊。&lt;/p&gt;

&lt;p&gt;但是問題又來了：對於一個雙音節詞語，前面的字會發生變調的情況，例如「食飯」，食的聲調是陽入，五度標音記作4或5，但是放在飯前面就要變成21了。&lt;/p&gt;

&lt;p&gt;所以我們就上一張變調表吧……(來源：&lt;a href=&quot;https://en.wikipedia.org/wiki/Fuzhou_dialect#Tonal_sandhi&quot;&gt;https://en.wikipedia.org/wiki/Fuzhou_dialect#Tonal_sandhi&lt;/a&gt;)&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;下字$\rightarrow$&lt;br /&gt;上字$\downarrow$&lt;/td&gt;
      &lt;td&gt;陰平˥&lt;/td&gt;
      &lt;td&gt;陽平˥˧&lt;br /&gt;陽入˥&lt;/td&gt;
      &lt;td&gt;上聲˧&lt;/td&gt;
      &lt;td&gt;陰去˨˩˧&lt;br /&gt;陽去˨˦˨&lt;br /&gt;陰入˨˦&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;陰平˥&lt;br /&gt;陰去˨˩˧&lt;br /&gt;陽去˨˦˨&lt;br /&gt;陰入乙˨˦&lt;/td&gt;
      &lt;td&gt;˥&lt;/td&gt;
      &lt;td&gt;˥&lt;/td&gt;
      &lt;td&gt;˥˧&lt;/td&gt;
      &lt;td&gt;˥˧&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;陽平˥˧&lt;br /&gt; 陽入˥&lt;/td&gt;
      &lt;td&gt;˥&lt;/td&gt;
      &lt;td&gt;˧&lt;/td&gt;
      &lt;td&gt;˧&lt;/td&gt;
      &lt;td&gt;˨˩&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;上聲˧&lt;br /&gt; 陰入甲˨˦&lt;/td&gt;
      &lt;td&gt;˨˩&lt;/td&gt;
      &lt;td&gt;˨˩&lt;/td&gt;
      &lt;td&gt;˧˥&lt;/td&gt;
      &lt;td&gt;˥&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中，陰入甲是舊時以-k收尾的字而陰入乙是以喉塞收尾的字。現在都以喉塞收尾了。&lt;/p&gt;

&lt;p&gt;其中入聲字有些的韻尾在連讀的時候被吃掉了，這部分字主要是陽入和陰入乙。&lt;/p&gt;

&lt;p&gt;那麼也就是說：&lt;/p&gt;

&lt;p&gt;對於下字是陰平的詞：&lt;/p&gt;

&lt;p&gt;若上字讀若陰平，則只能排除上聲和陰入甲。需要結合普通話判定平聲還是去聲，入聲就也不能分離出了。&lt;/p&gt;

&lt;p&gt;若上字讀若變降，則可以知道會是上聲或者陰入甲。陰入甲較多的有保留喉塞，例如「國家」，可以區分清楚。&lt;/p&gt;

&lt;p&gt;對於下字是陽平或者陽入的詞：&lt;/p&gt;

&lt;p&gt;若上字讀若陰平，則可以知道是陰平，陰去，陽去或者陰入乙。其中若有保留喉塞音或者普通話是上聲字則這個字會是陰入乙，否則也比較難區分開。&lt;/p&gt;

&lt;p&gt;若上字讀若上聲，則可以知道會是陽平或者陽入，而如果這個字是次濁字則可以確定這是陽平字，否則就混起來了……&lt;/p&gt;

&lt;p&gt;若上字讀若變降，則知道是上聲或者陰入甲，同理。&lt;/p&gt;

&lt;p&gt;下字聲調的其餘情況也與上面一類同理可以推得到。&lt;/p&gt;

&lt;p&gt;所以基本上除了陰入甲也都還不是很容易解決。（因爲上字的混同與普通話有些類似。）&lt;/p&gt;

&lt;p&gt;所以區分入聲字還有一個方法……&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;郭沫若沒出息！[滑稽]&lt;/h3&gt;

&lt;p&gt;然而郭沫若能寫出這種東西還真的是很強啊……&lt;/p&gt;

&lt;p&gt;要是能有人把全濁上聲字也寫成一篇東西就好啦……&lt;/p&gt;
</description>
        <pubDate>Tue, 27 Mar 2018 00:00:00 +0800</pubDate>
        <link>https://alphagem.github.io/2018/03/27/%E7%8F%BE%E5%AD%B8%E7%8F%BE%E8%B3%A3%E9%9F%B3%E9%9F%BB%E5%AD%B8%E9%9A%A8%E8%A8%98%E4%B8%80-%E5%BE%9E%E6%99%AE%E9%80%9A%E8%A9%B1%E7%A6%8F%E5%B7%9E%E8%A9%B1%E9%80%B2%E8%A1%8C%E7%B0%A1%E5%96%AE%E4%B8%AD%E5%8F%A4%E6%BC%A2%E8%AA%9E%E8%81%B2%E8%AA%BF%E6%8E%A8%E5%B0%8E.html</link>
        <guid isPermaLink="true">https://alphagem.github.io/2018/03/27/%E7%8F%BE%E5%AD%B8%E7%8F%BE%E8%B3%A3%E9%9F%B3%E9%9F%BB%E5%AD%B8%E9%9A%A8%E8%A8%98%E4%B8%80-%E5%BE%9E%E6%99%AE%E9%80%9A%E8%A9%B1%E7%A6%8F%E5%B7%9E%E8%A9%B1%E9%80%B2%E8%A1%8C%E7%B0%A1%E5%96%AE%E4%B8%AD%E5%8F%A4%E6%BC%A2%E8%AA%9E%E8%81%B2%E8%AA%BF%E6%8E%A8%E5%B0%8E.html</guid>
        
        <category>語言音韻</category>
        
        <category>中古漢語</category>
        
        <category>福州話</category>
        
        
        <category>linguistics</category>
        
      </item>
    
      <item>
        <title>分治最小割与其证明</title>
        <description>&lt;p&gt;校内互测的时候搬了个分治最小割板子题(CQOI2016)，然后结果讲题的时候被要求证明分治最小割的结论，结果就尬住了……&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;什么是分治最小割？&lt;/h3&gt;

&lt;p&gt;看一个例题，这个题就是上面提到的CQOI2016的分治最小割板子题“不同的最小割”。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;学过图论的同学都知道最小割的概念：对于一个图，某个对图中结点的划分将图中所有结点分成两个部分，如果结点 $s,t$ 不在同一个部分中，则称这个划分是关于 $s,t$ 的割。对于带权图来说，将所有顶点处在不同部分的边的权值相加所得到的值定义为这个割的容量，而 $s,t$ 的最小割指的是在关于 $s,t$ 的割中容量最小的割。&lt;/p&gt;

  &lt;p&gt;对冲刺 NOI 竞赛的选手而言，求带权图中两点的最小割已经不是什么难事了。我们可以把视野放宽，考虑有 $N$ 个点的无向连通图中所有点对的最小割的容量，共能得到 $\frac{N(N−1)}{2}$ 个数值。这些数值中互不相同的有多少个呢？这似乎是个有趣的问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;于是我们就强行套用结论解决了这个问题：&lt;/p&gt;

&lt;p&gt;首先，一个图中不同的最小割最多有 $n-1$ 个，并且采用分治最小割模板我们可以求出这 $n-1$ 个不同的最小割。对于这道题，我们把这些最小割sort一下unique一下就完事了。&lt;/p&gt;

&lt;p&gt;而分治最小割的模板是这样的：&lt;/p&gt;

&lt;p&gt;对于一个图 $G=(V,E)$，假设我们现在当前工作中的点的集合是 $S$，其中 $S\subseteq V$ ；&lt;/p&gt;

&lt;p&gt;我们就从 $S$ 中选出一个点 $s$ 和一个点 $t$，在原图 $G$ 上以 $s$ 为源，$t$ 为汇跑一遍最小割；&lt;/p&gt;

&lt;p&gt;假设割出来两个集合分别叫做 $A$ 和 $B$，则最小割的代价为 $w$，且 $s$ 在集合 $A$ 中，$t$ 在集合 $B$ 中，那么我们就知道 $A$ 到 $B$ 的任意点对最小割都会是 $w$。我们就可以暴力更新 $A,B$ 间的点对的最小割。&lt;/p&gt;

&lt;p&gt;然后递归处理 $S=A\cap S$ 和 $S=B\cap S$ 的情况。&lt;/p&gt;

&lt;p&gt;最后我们就求出了任意点对的最小割。&lt;/p&gt;

&lt;p&gt;为什么这是对的？&lt;/p&gt;

&lt;p&gt;于是开始搜索相关的证明/说明，结果要么是“我不会”，要么是随便口糊了一下，要么是机翻风格……反正看着不是很舒服。&lt;/p&gt;

&lt;p&gt;所以就记个板子到此结束了？&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;你改悔罢！&lt;/h3&gt;

&lt;p&gt;接下来开始一段乱七八糟的说明。这段说明的目标是在大致保证严谨性的前提下尽可能让人读懂，但是由于语文和OI水平均有限，所以……&lt;/p&gt;

&lt;p&gt;对于图 $G=(V,E)$，考虑其中不同的两个点 $A_0,D_0$，假设在图上对于 $A_0,D_0$ 跑了一遍最小割以后把图分成了 $S,T$ 两个集合，然后再取不同的两个点 $B_0,C_0$，假设 $B_0,C_0$ 在图 $G$ 上跑一遍最小割以后图被分成了 $X,Y$ 两个集合。&lt;/p&gt;

&lt;p&gt;同时我们不妨设 $A_0\in S,D_0\in T;C_0\in X, B_0\in Y$。&lt;/p&gt;

&lt;p&gt;我们首先需要说明对于一对 $S,T$ &lt;strong&gt;存在&lt;/strong&gt;一对 $X$ 与 $Y$ 使得 $S\subseteq X$ 或 $X\subseteq S$，即 $S\cap X,T\cap X,S\cap Y,T\cap Y$ 这四个把图恰好分成了四份的集合中有一份为空，通俗地来讲就是“最小割不跨立”。如果这个结论是对的，我们就可以从这个结论推出上面的递归处理部分是正确的。&lt;/p&gt;

&lt;p&gt;直接做不好下手，于是考虑使用反证法。&lt;/p&gt;

&lt;p&gt;不妨设 $S\cap X,S\cap Y,T\cap X,T\cap Y$ 分别为 $A,B,C,D$，且这四个集合都不为空。&lt;/p&gt;

&lt;p&gt;那么实际上就是 $A\cup B=S,C\cup D=T,A\cup C=X,B\cup D=Y$。&lt;/p&gt;

&lt;p&gt;各个集合缩点以后连边情况如图所示。图中 $S,T,X,Y$ 分别是上二个、下二个、左二个、右二个。&lt;/p&gt;

&lt;p&gt;也就是说 $A_0$ 在上半边，$B_0$ 在右半边，$C_0$ 在左半边，$D_0$ 在下半边。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018-03-21-s1.png&quot; alt=&quot;[pic1]&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中，$A_0$ 与 $D_0$ 不会在一个缩完的点中，$B_0$ 与 $C_0$ 不会在一个缩完的点中，否则就没有割开。&lt;/p&gt;

&lt;p&gt;分几种情况讨论：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;$A_0,B_0,C_0,D_0$ 中有某两个点在 $A,B,C,D$ 中的同一个集合内（可能重合）。&lt;/p&gt;

    &lt;p&gt;此时如果另外两个点在同一个集合内，那么显然我们只要令 $X=S,Y=T$ 就完事了。&lt;/p&gt;

    &lt;p&gt;于是这里不妨假设是 $A_0$ 与 $C_0$ 都在集合 $A$ 中，而 $B_0$ 在 $B$ 中，$D_0$ 在 $D$ 中。&lt;/p&gt;

    &lt;p&gt;首先考虑 $C_0$ 与 $B_0$ 的所有可能成为最小割的割。它们分别是&lt;/p&gt;

    &lt;p&gt;$a+b+e,a+c+e+f,a+f+d$&lt;/p&gt;

    &lt;p&gt;由于 $C_0$ 与 $B_0$ 的实际上的最小割是分隔了 $S,T$ 的 $a+c+e+f$，那么我们有&lt;/p&gt;

    &lt;p&gt;$a+c+e+f\le a+b+e$ 即 $c+f\le b$&lt;/p&gt;

    &lt;p&gt;$a+c+e+f\le a+f+d$ 即 $c+e\le d$&lt;/p&gt;

    &lt;p&gt;同样地，考虑 $A_0$ 与 $D_0$ 的最小割，我们可以得到&lt;/p&gt;

    &lt;p&gt;$f+d\le a$&lt;/p&gt;

    &lt;p&gt;$b+e\le c$&lt;/p&gt;

    &lt;p&gt;$b+d\le a+c$&lt;/p&gt;

    &lt;p&gt;解不等式可以得到 $e=0,f=0,b=c$。于是实际上 $X-Y$ 的割可以被从 $a+c$（这里 $e,f$ 已经是 $0$ 了所以舍去）被等效为 $a+b$ ，也就是相当于我们把 $C$ 集合从 $X$ 集合里面挖了出来丢到了 $Y$ 里面。这个时候 $T\cap X’=T\cap A$ 就为空集啦！&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$A_0,B_0,C_0,D_0$ 在四个不同的集合内。&lt;/p&gt;

    &lt;p&gt;则不妨设 $A_0\in A,B_0\in B,C_0\in C,D_0\in D$。&lt;/p&gt;

    &lt;p&gt;这时候令 $X=S,Y=T$ 也是可以的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;于是我们就证明完了上面的这个结论：&lt;strong&gt;存在&lt;/strong&gt;一种方案使得四个集合有一个为空。也就是只会分出三个非空集合。&lt;/p&gt;

&lt;p&gt;好的。考虑递归处理部分。现在还是设当前在处理 $S$ ，它被割成了 $A,B$ 两个子集。对于一个集合 $A$ 中取出的两个点，它们的最小割一定会把这个集合 $A$ 分成两个非空集合。根据上面的结论，存在一种方案只分出三个非空集合，所以说存在方案 $A$ 中的点不会把 $B$ 集合割开，就影响不到 $B$ 集合内部某两个点的割，分治是对的。&lt;/p&gt;

&lt;p&gt;做完啦！&lt;/p&gt;
</description>
        <pubDate>Wed, 21 Mar 2018 00:00:00 +0800</pubDate>
        <link>https://alphagem.github.io/2018/03/21/%E5%88%86%E6%B2%BB%E6%9C%80%E5%B0%8F%E5%89%B2%E4%B8%8E%E5%85%B6%E8%AF%81%E6%98%8E.html</link>
        <guid isPermaLink="true">https://alphagem.github.io/2018/03/21/%E5%88%86%E6%B2%BB%E6%9C%80%E5%B0%8F%E5%89%B2%E4%B8%8E%E5%85%B6%E8%AF%81%E6%98%8E.html</guid>
        
        <category>信息竞赛</category>
        
        <category>网络流</category>
        
        
        <category>OI</category>
        
      </item>
    
      <item>
        <title>Linux中Gedit的脚本设置</title>
        <description>&lt;p&gt;因为后面可能非常非常经常要用Gedit写题了，所以来总结一下如何用Gedit的脚本功能来搭建一个舒服的调题环境为妙。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;基础配置&lt;/h3&gt;

&lt;p&gt;首先找到Gedit的偏好设定并且将运行外部脚本的功能开起来，然后打开工具找到“管理外部插件”并且新建一个内容如下的脚本：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;    &lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$GEDIT_CURRENT_DOCUMENT_DIR&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$GEDIT_CURRENT_DOCUMENT_NAME&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$s&lt;/span&gt;|cut -d. -f1&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;
    g++ &lt;span class=&quot;nv&quot;&gt;$s&lt;/span&gt; -o &lt;span class=&quot;nv&quot;&gt;$c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Success!&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Now let&#39;s go...&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    gnome-terminal --working-directory&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$d&lt;/span&gt; -x bash -c &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;time &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$d&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$c&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;; echo; echo &#39;Press ENTER to continue...&#39;;read&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;（这里末尾有\的是指接下一行，至于最后一段的用&amp;amp;&amp;amp;连接是为了编译失败就不运行。在实际使用的时候可以不换行并且删掉\字符，这里使用是为了能够保证代码长度不超过框框的宽度）&lt;/p&gt;

&lt;p&gt;那这里面的句子是什么意思呢？&lt;/p&gt;

&lt;p&gt;其中第一行代表这是一个脚本。&lt;/p&gt;

&lt;p&gt;第二行定义了一个值为当前目录的变量。&lt;/p&gt;

&lt;p&gt;第三行定义了一个值为当前的cpp文件名的变量。&lt;/p&gt;

&lt;p&gt;第四行是把当前的文件名以点分割并且取前半段。注意这里使用的是重音符 ‘`‘，不要打成单引号啦~&lt;/p&gt;

&lt;p&gt;第五行是先编译运行当前的cpp文件（g++ \$s -o \$c）；&lt;/p&gt;

&lt;p&gt;然后在下方的提示框里面输出成功的消息（两个echo）；&lt;/p&gt;

&lt;p&gt;接着打开一个新终端（gnome-terminal）：&lt;/p&gt;

&lt;p&gt;先把这个终端的运行目录设定成当前的目录（–working-directory=\$d），然后是调用bash的-x bash，然后是在这个bash里面执行一些命令（-c），命令的内容用双引号包起来。命令的内容首先是计时地运行你的程序（time \$d/\$c），注意这里是绝对路径，接着输出一个换行（echo），然后输出一行提示信息（echo ‘Press ENTER to continue’，注意是单引号），最后一个read实现输入等到回车后再关闭窗口。&lt;/p&gt;

&lt;p&gt;接着把它保存为快捷键Ctrl+F11，并保存当前文件即可。&lt;/p&gt;

&lt;p&gt;接下来按下Ctrl+F11，如果编译失败就会在下方显示错误信息，成功就会新弹出一个超级良心der终端，是给这个程序专用的，再也不用担心做题的时候程序提前退出然后因为是用粘贴的结果就在终端里面打了一堆乱七八糟的命令x&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;调试模式&lt;/h3&gt;

&lt;p&gt;新开一个脚本，把刚刚那一段东西里面的g++后面的编译命令里增加一个-DDEBUG，这个脚本快捷键保存为Ctrl+F8，然后在自己的代码开头加入如下一段内容：&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;    &lt;span class=&quot;cp&quot;&gt;#ifdef DEBUG
&lt;/span&gt;    &lt;span class=&quot;cp&quot;&gt;#define debug(a...) fprintf(stderr,a),fflush(stderr)
&lt;/span&gt;    &lt;span class=&quot;cp&quot;&gt;#else
&lt;/span&gt;    &lt;span class=&quot;cp&quot;&gt;#define debug(a...) 1
&lt;/span&gt;    &lt;span class=&quot;cp&quot;&gt;#endif&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;然后接下来在代码里面要调试的地方直接调用debug函数，例如&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;    &lt;span class=&quot;n&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;x=%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;于是调用这个函数就可以往stderr里面输出debug语句，并&lt;strong&gt;利用fflush让它立即显示在屏幕上&lt;/strong&gt;了。（这很重要，我被坑过，就是因为东西还堆在IO缓冲区内导致输出语句很诡异而调不出题）&lt;/p&gt;

&lt;p&gt;接下来就可以实现如果是Ctrl+F8就可以输出调试语句，按Ctrl+F11不会输出，评测的时候也不会输出的功能惹。&lt;/p&gt;

&lt;p&gt;注意：在第二个define里面要把debug(a…)替换成1而不是空，防止自己一不小心就打出&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;x=%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;werken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;这样的代码，然后就成功在正式测试的时候CE啦！&lt;/p&gt;

&lt;p&gt;当然，自己定义一个新的空函数也是可以的。&lt;/p&gt;

&lt;p&gt;但是还是要注意的是如果你为了调试在 $O(n)$ 的算法里面调用了 $O(n^2)$ 次的啥都不会干的debug函数不删仍然是会T得很惨的吧……&lt;/p&gt;

&lt;p&gt;所以也不是万能的。（这句话的深层含义：出锅了不要打我啊喂！）&lt;/p&gt;

&lt;p&gt;于是就可以成功地在debug和release模式之间自由切换了x&lt;/p&gt;

&lt;p&gt;关于进一步的科技，可以参照&lt;a href=&quot;/2018/04/18/输出语句调试科技系列.html&quot;&gt;输出语句调试科技系列&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;python&quot;&gt;适用于python的版本&lt;/h3&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;    &lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$GEDIT_CURRENT_DOCUMENT_DIR&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$GEDIT_CURRENT_DOCUMENT_NAME&lt;/span&gt;
    gnome-terminal --working-directory&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$d&lt;/span&gt; -x bash -c &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;python &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$d&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$s&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;; echo; echo &#39;Press ENTER to continue...&#39;;read&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;于是就可以喜闻乐见地直接快捷键运行python了。&lt;/p&gt;

&lt;p&gt;所以大概就长成这样子了如果读不懂可能就是我的语文能力问题了这我也救不了自己了。&lt;/p&gt;
</description>
        <pubDate>Sun, 11 Mar 2018 00:00:00 +0800</pubDate>
        <link>https://alphagem.github.io/2018/03/11/Linux%E4%B8%ADGedit%E7%9A%84%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AE.html</link>
        <guid isPermaLink="true">https://alphagem.github.io/2018/03/11/Linux%E4%B8%ADGedit%E7%9A%84%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AE.html</guid>
        
        <category>信息竞赛</category>
        
        <category>电脑操作</category>
        
        <category>Linux</category>
        
        <category>Gedit</category>
        
        <category>脚本</category>
        
        <category>调试</category>
        
        
        <category>OI</category>
        
        <category>computer</category>
        
      </item>
    
      <item>
        <title>NOIWC2018游记</title>
        <description>&lt;p&gt;到长沙&lt;del&gt;玩了一发&lt;/del&gt;参加了NOI2018冬眠营，然后因为太弱正解基本都没听懂，但是学了一堆的奇奇怪怪的东西，像什么分析方法乱搞骗分之类的，这里把个人认为比较好的idea不完全列举如下。&lt;del&gt;不过感觉拿出去应该都是烂大街的东西。&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;势能函数分析&lt;/h3&gt;

&lt;p&gt;为了分析算法的时间复杂度/正确性等，我们引入当前状态的势能函数，然后证明每次操作势能函数的变化量一定满足一些条件，来推出算法的时间复杂度/正确性是对的。&lt;/p&gt;

&lt;p&gt;比如说我们现在要证明一个算法跑出的解不会超过最优解的 $k$ 倍，那么我们就引入势能函数 $\phi$ 代表当前我们的状态下我们离最优解差多少（这里 $\phi$ 的设计需要比较合理），然后假设最优解和我们分别操作一轮，最优解使 $\phi$ 增大了 $kd$，而我们的操作使 $\phi$ 减少了 $d$，那么我们就证明出了我们的算法跑出的解确实不会超过最优解的 $k$ 倍。&lt;/p&gt;

&lt;p&gt;这样做便于数学表述。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;判断点在多边形内&lt;/h3&gt;

&lt;p&gt;你不一定要作射线去跟多边形交，可以作折线，这样就可以支持特定情况下点的移动了（比如网格图里面）。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;遗传算法的全过程&lt;/h3&gt;

&lt;p&gt;//预计开一个新坑，然后配一道题来说，后面可能会把链接挂过来。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;蚁群算法的全过程&lt;/h3&gt;

&lt;p&gt;//同上。&lt;/p&gt;

&lt;h3 id=&quot;fft&quot;&gt;FFT的物理意义&lt;/h3&gt;

&lt;p&gt;其实我最早学FFT的时候是这样的：&lt;/p&gt;

&lt;p&gt;-要学FFT肯定要先学FT呀！&lt;/p&gt;

&lt;p&gt;（学了好久好久的FT，爆肝物理）&lt;/p&gt;

&lt;p&gt;-我大概了解FT在干什么了。那么FFT呢？&lt;/p&gt;

&lt;p&gt;（开始看FFT）&lt;/p&gt;

&lt;p&gt;-FFT和FT有什么关系么！你说时域转成频域就可以做乘积，然后就贴了一个板子，这个板子是在做什么呀！&lt;/p&gt;

&lt;p&gt;（滚回去继续理解FT）&lt;/p&gt;

&lt;p&gt;-完全无法理解[托腮]&lt;/p&gt;

&lt;p&gt;（最后还是选择了背板）&lt;/p&gt;

&lt;p&gt;然后大概这次才是基本弄清楚了FT到底是怎么到FFT的。实际上大概就是物理是玩这个世界，然后玩着玩着开始推数学，但是数学是造一个世界自己玩，然后就越玩越远了x&lt;/p&gt;

&lt;p&gt;不过FT还是确实挺有用的（看起来Praat这个软件就是跑了个FT来分析共振峰，共振峰分析在语音学上也还是蛮有用的吧。所以说各个学科还是相互服务的。）&lt;/p&gt;

&lt;p&gt;具体大约要看松松松的课件我在这里可能讲不清楚x&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;从现有的算法来看待问题，尤其是交互式题目&lt;/h3&gt;

&lt;p&gt;比如说像营里面课上有一个交互题，题意是这样的：有一张&lt;strong&gt;有向图&lt;/strong&gt;，$n$ 个点，每个点是一个房间，度数为 $m$ ，即从房间有 $m$ 条长得一模一样的通道连出去，房间的正中间有一个石子（后面的石子可能就被移动不在中间了），你每次在一个房间里的时候可以把石子放到一条通道的左边或者右边，然后选择一条通道走出去。这里因为通道长得一样，所以你的参照物是石子，你放置石子或者走通道只能够说”我选择我刚进入这个房间的时候房间里面石子的位置顺时针转过多少个通道的那个通道“。你被随机丢到了一个房间里面，你需要遍历这个图。&lt;/p&gt;

&lt;p&gt;然后就是Tarjan改版，记一下返祖边和横叉边。&lt;/p&gt;

&lt;p&gt;还有后面比赛的题目，有一颗树，一开始只有 $1$ 已知，每一次你需要选择一个已知点 $x$ 和一个点 $y$ ，然后交互库会返回 $x$ 到 $y$ 路径上离 $x$ 最近的点 $z$，并且如果 $z$ 是未知点，它就会被标记成已知点（开地图过程）。然后你需要用 $nlogn$ 级别的操作次数开完整个地图。&lt;/p&gt;

&lt;p&gt;利用替罪羊树的重构思想可以高分甚至 $AC$。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;一些长得像“树上最长链”一样的问题的近似求解&lt;/h3&gt;

&lt;p&gt;可以使用类似于找最长链的方法，找一个基准点，找到离它最远的点，接着以这个点为基准点重复上面的操作，多次迭代，并且多选几次基准点，就有可能跑出优秀的解。&lt;/p&gt;

&lt;h3 id=&quot;etc&quot;&gt;etc…&lt;/h3&gt;

&lt;p&gt;然后学着学着就比赛了，比赛的时候T2看错题意，居然直接过了大样例，出考场完听别人说题面出锅了我才发现自己看错了题意。于是就因为这个看错题意节省了一堆时间，但是最后T1还是有12分暴力没调出来，最后就滚粗了。而且感觉自己预支了省选的RP[害怕.jpg]。&lt;/p&gt;
</description>
        <pubDate>Thu, 08 Feb 2018 00:00:00 +0800</pubDate>
        <link>https://alphagem.github.io/2018/02/08/NOIWC2018%E6%B8%B8%E8%AE%B0.html</link>
        <guid isPermaLink="true">https://alphagem.github.io/2018/02/08/NOIWC2018%E6%B8%B8%E8%AE%B0.html</guid>
        
        <category>信息竞赛</category>
        
        <category>NOIWC2018</category>
        
        
        <category>OI</category>
        
      </item>
    
  </channel>
</rss>
